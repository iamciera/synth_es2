if (j == (length(base[1,])+1)){
output[i,j] <- cells - base[i,(j-1)]
}
else if (j==1){
output[i,j] <- base[i,j]
}
else{
output[i,j] <- base[i,(j)] - base[i,(j-1)]
}
}
}
calc <- matrix[ncol = 2, nrow = length(output[,1]))
calc <- matrix[ncol = 2, nrow = length(output[,1])
calc <- matrix(ncol = 2, nrow = length(output[,1])
calc <- matrix(ncol = 2, nrow = length(output[,1])
)
for (i in 1:length(output[,1])){
c <- n
m <- 1
for (j in 1:length(output[1,])){
m <- (factorial(c)/(factorial(output[i,j])factorial(c-output[i,j])))*m
c <- c - output[i,j]
}
calc[i,1] <- max(output[i,])
calc[i,2] <- m
}
for (j in 1:length(output[1,])){
m <- (factorial(c)/(factorial(output[i,j])factorial(c-output[i,j])))*m
c <- c - output[i,j]
}
for (j in 1:length(output[1,])){
m <- (factorial(c)/(factorial(output[i,j])factorial(c-output[i,j])))*m
c <- c - output[i,j]
}
m <- (factorial(c)/(factorial(output[i,j])factorial(c-output[i,j])))*m
m <- (factorial(c)/(factorial(output[i,j])*factorial(c-output[i,j])))*m
for (i in 1:length(output[,1])){
c <- n
m <- 1
for (j in 1:length(output[1,])){
m <- (factorial(c)/(factorial(output[i,j])*factorial(c-output[i,j])))*m
c <- c - output[i,j]
}
calc[i,1] <- max(output[i,])
calc[i,2] <- m
}
warnings()
c <- n
View(output)
for (i in 1:length(output[,1])){
c <- n + 1
m <- 1
for (j in 1:length(output[1,])){
m <- (factorial(c)/(factorial(output[i,j])*factorial(c-output[i,j])))*m
c <- c - output[i,j]
}
calc[i,1] <- max(output[i,])
calc[i,2] <- m
}
View(calc)
sum(calc[,2])
5^10
4^10
sum(calc[,2])/4^10
View(base)
View(output)
View(calc)
View(output)
10*9*8*6
10*9*8*7*6
sum(calc[,2])/5^10
i <- 1
c <- n + 1
m <- 1
for (j in 1:length(output[1,])){
m <- (factorial(c)/(factorial(output[i,j])*factorial(c-output[i,j])))*m
c <- c - output[i,j]
}
c <- n + 1
m <- 1
for (j in 1:1){
m <- (factorial(c)/(factorial(output[i,j])*factorial(c-output[i,j])))*m
c <- c - output[i,j]
}
c <- n + 1
m <- 1
for (j in 1:2){
m <- (factorial(c)/(factorial(output[i,j])*factorial(c-output[i,j])))*m
c <- c - output[i,j]
}
c <- n + 1
m <- 1
for (j in 1:4){
m <- (factorial(c)/(factorial(output[i,j])*factorial(c-output[i,j])))*m
c <- c - output[i,j]
}
c <- n + 1
m <- 1
for (j in 1:5){
m <- (factorial(c)/(factorial(output[i,j])*factorial(c-output[i,j])))*m
c <- c - output[i,j]
}
c <- n + 1
m <- 1
for (j in 1:4){
m <- (factorial(c)/(factorial(output[i,j])*factorial(c-output[i,j])))*m
c <- c - output[i,j]
}
factorial(c)
factorial(c-output[i,j])
output[i,j]
View(output)
j <- 5
m <- (factorial(c)/(factorial(output[i,j])*factorial(c-output[i,j])))*m
View(h)
View(output)
check <- vector()
check <- vector()
for (i in 1:length(output[,1])){
check[i] <- output[i,1] + output[i,2]*10 + output[i,3]*10^2 + output[i,4]*10^3 + output[i,5]*10^4
}
check <- order[check]
check <- order[check[i:7260]]
library(dplyr)
check <- arrange(check,V1)
check <- as.data.frame(check)
check <- arrange(check,V1)
View(check)
check <- arrange(check,check)
View(check)
##General Algorithmic Solution to Birthday Problem
rm(list = ls())
n <- 3
k <- 2
template <- matrix(nrow=(n-k), ncol = k)
for (i in 1:k){
for (j in 1:(n-k)){
template[j,i] <- i + j - 1
}
}
View(template)
for (i in 1:k){
for (j in 1:(n-k+1)){
template[j,i] <- i + j - 1
}
}
n <- 3
k <- 2
template <- matrix(nrow=(n-k), ncol = k)
for (i in 1:k){
for (j in 1:(n-k+1)){
template[j,i] <- i + j - 1
}
}
template <- matrix(nrow=(n-k+1), ncol = k)
for (i in 1:k){
for (j in 1:(n-k+1)){
template[j,i] <- i + j - 1
}
}
base <- template
for (i in (k-1):1){
for (j in 1:length(base[,1])) {
if (j != length(base[,1])){
h <- merge(t(base[j,1:i]),as.data.frame(base[j:length(base[,1]),(i+1):k]),by = NULL)
}
else{
h <- cbind(t(base[j,1:i]),t(base[j:length(base[,1]),(i+1):k]))
}
if (j == 1){
g <- h
}
else{
g <- rbind(as.matrix(g),as.matrix(h))
}
}
base <- g
}
View(base)
cells <- n+1
output <- 0*cbind(base,base[,1])
for (i in 1:length(base[,1])){
for (j in (length(base[1,])+1):1){
if (j == (length(base[1,])+1)){
output[i,j] <- cells - base[i,(j-1)]
}
else if (j==1){
output[i,j] <- base[i,j]
}
else{
output[i,j] <- base[i,(j)] - base[i,(j-1)]
}
}
}
View(output)
calc <- matrix(ncol = 2, nrow = length(output[,1]))
for (i in 1:length(output[,1])){
c <- n + 1
m <- 1
for (j in 1:length(output[1,])){
m <- (factorial(c)/(factorial(output[i,j])*factorial(c-output[i,j])))*m
c <- c - output[i,j]
}
calc[i,1] <- max(output[i,])
calc[i,2] <- m
}
View(calc)
View(output)
View(calc)
View(h)
View(output)
##General Algorithmic Solution to Birthday Problem
rm(list = ls())
n <- 5
k <- 2
template <- matrix(nrow=(n-k+1), ncol = k)
for (i in 1:k){
for (j in 1:(n-k+1)){
template[j,i] <- i + j - 1
}
}
base <- template
for (i in (k-1):1){
for (j in 1:length(base[,1])) {
if (j != length(base[,1])){
h <- merge(t(base[j,1:i]),as.data.frame(base[j:length(base[,1]),(i+1):k]),by = NULL)
}
else{
h <- cbind(t(base[j,1:i]),t(base[j:length(base[,1]),(i+1):k]))
}
if (j == 1){
g <- h
}
else{
g <- rbind(as.matrix(g),as.matrix(h))
}
}
base <- g
}
##interpret--convert to list of macrostates
cells <- n+1
output <- 0*cbind(base,base[,1])
for (i in 1:length(base[,1])){
for (j in (length(base[1,])+1):1){
if (j == (length(base[1,])+1)){
output[i,j] <- cells - base[i,(j-1)]
}
else if (j==1){
output[i,j] <- base[i,j]
}
else{
output[i,j] <- base[i,(j)] - base[i,(j-1)]
}
}
}
##weight by # microstates
calc <- matrix(ncol = 2, nrow = length(output[,1]))
for (i in 1:length(output[,1])){
c <- n + 1
m <- 1
for (j in 1:length(output[1,])){
m <- (factorial(c)/(factorial(output[i,j])*factorial(c-output[i,j])))*m
c <- c - output[i,j]
}
calc[i,1] <- max(output[i,])
calc[i,2] <- m
}
sum(calc[,2])
3^6
rm(list = ls())
n <- 10
k <- 4
template <- matrix(nrow=(n-k+1), ncol = k)
for (i in 1:k){
for (j in 1:(n-k+1)){
template[j,i] <- i + j - 1
}
}
base <- template
for (i in (k-1):1){
for (j in 1:length(base[,1])) {
if (j != length(base[,1])){
h <- merge(t(base[j,1:i]),as.data.frame(base[j:length(base[,1]),(i+1):k]),by = NULL)
}
else{
h <- cbind(t(base[j,1:i]),t(base[j:length(base[,1]),(i+1):k]))
}
if (j == 1){
g <- h
}
else{
g <- rbind(as.matrix(g),as.matrix(h))
}
}
base <- g
}
##interpret--convert to list of macrostates
cells <- n+1
output <- 0*cbind(base,base[,1])
for (i in 1:length(base[,1])){
for (j in (length(base[1,])+1):1){
if (j == (length(base[1,])+1)){
output[i,j] <- cells - base[i,(j-1)]
}
else if (j==1){
output[i,j] <- base[i,j]
}
else{
output[i,j] <- base[i,(j)] - base[i,(j-1)]
}
}
}
##weight by # microstates
calc <- matrix(ncol = 2, nrow = length(output[,1]))
for (i in 1:length(output[,1])){
c <- n + 1
m <- 1
for (j in 1:length(output[1,])){
m <- (factorial(c)/(factorial(output[i,j])*factorial(c-output[i,j])))*m
c <- c - output[i,j]
}
calc[i,1] <- max(output[i,])
calc[i,2] <- m
}
sum(calc[,2])
5^11
(factorial(22)/(factorial(2)(factorial(20))))*(1/365)
(factorial(22)/(factorial(2)*(factorial(20))))*(1/365)
(factorial(21)/(factorial(2)*(factorial(20))))*(1/365)
(factorial(23)/(factorial(2)*(factorial(20))))*(1/365)
(factorial(n)/(factorial(2)*(factorial(n-2))))*(1/365)
n <- 22
(factorial(n)/(factorial(2)*(factorial(n-2))))*(1/365)
n <- 23
(factorial(n)/(factorial(2)*(factorial(n-2))))*(1/365)
n <- 27
(factorial(n)/(factorial(2)*(factorial(n-2))))*(1/365)
n <- 45
(factorial(n)/(factorial(2)*(factorial(n-2))))*(1/365)
(factorial(n)/(factorial(2)*(factorial(n-2))))
45*44/2
(factorial(n)/(factorial(2)*(factorial(n-2))))*(2/365)^2
#check for HindIII sites on synthetic ES2
rm(list = ls())
setwd(getwd())
library(Biostrings)
library(dplyr)
source('../utilities/header.R')
#check for HindIII sites on synthetic ES2
rm(list = ls())
setwd(getwd())
library(Biostrings)
library(dplyr)
source('../utilities/header.R')
getwd()
#check for HindIII sites on synthetic ES2
rm(list = ls())
setwd(getwd())
library(Biostrings)
library(dplyr)
source('../utilities/header.R')
getwd()
#import and FIMO results and generate annotated ES2 seq
rm(list = ls())
setwd(getwd())
library(Biostrings)
library(dplyr)
source('../utilities/header.R')
#####Project#######
project <- '/ToFIMO/Results_12.01.16/'
#####IMPORTS######
es2Min <- as.numeric(substr(read.csv(paste0(ReadPath,'/ES2MinSeq.csv'), header = TRUE, sep = ",")[1,5],4,10))
TFranges <- read.csv(paste0(AnalyzePath,'/RFtfbs.csv'), header = TRUE, sep = ",")
csvFIMO <- read.csv(paste0(AnalyzePath,project,'fimo0.1.csv'),sep=',',header=TRUE)
FullTFRaw <- sapply(read.csv(paste0(ReadPath,'/redfly_tfbs.csv'), header = TRUE, sep = ",")[1:27,c(1,5,6)], as.character)
#####DEFINE VARIABLES, CLEAN SETS#####
offset <- 49 #offset between start of full ES2 and minimal
TFminNorm <- TFranges
TFminNorm[,3:4] <- TFminNorm[,3:4] - es2Min + 1 + offset
MinMax <- max(TFminNorm[,4])
seqL <- 898 #length of full dmel ES2
origin <- es2Min - offset
TFClean <- data.frame(FullTFRaw) %>%
mutate(start = as.numeric(substr(coordinates,4,10))-origin + 1,
stop = as.numeric(substr(coordinates,13,19))-origin + 1,
name = tolower(substr(name,1,unlist(gregexpr('_',name))-1)),
pValue = 0,
pattern=name) %>%
select(pattern, start, stop, sequence, pValue)
#####confrim that min and full coordinates match#####
check <- full_join(TFClean,
select(TFminNorm,-X), c("start" = "X2","stop" = "X3")) %>%
arrange(start,stop)
getwd()
getwd()
#import and FIMO results and generate annotated ES2 seq
rm(list = ls())
setwd('C:\Users\Nicholas\Documents\GitHub\synth_es2\code\analysis')
library(Biostrings)
library(dplyr)
source('../utilities/header.R')
#####Project#######
project <- '/ToFIMO/Results_12.01.16/'
#####IMPORTS######
es2Min <- as.numeric(substr(read.csv(paste0(ReadPath,'/ES2MinSeq.csv'), header = TRUE, sep = ",")[1,5],4,10))
TFranges <- read.csv(paste0(AnalyzePath,'/RFtfbs.csv'), header = TRUE, sep = ",")
csvFIMO <- read.csv(paste0(AnalyzePath,project,'fimo0.1.csv'),sep=',',header=TRUE)
FullTFRaw <- sapply(read.csv(paste0(ReadPath,'/redfly_tfbs.csv'), header = TRUE, sep = ",")[1:27,c(1,5,6)], as.character)
rm(list = ls())
setwd("C:\Users\Nicholas\Documents\GitHub\synth_es2\code\analysis")
setwd("C:/Users/Nicholas/Documents/GitHub/synth_es2/code/analysis")
library(Biostrings)
library(dplyr)
source('../utilities/header.R')
#####Project#######
project <- '/ToFIMO/Results_12.01.16/'
#####IMPORTS######
es2Min <- as.numeric(substr(read.csv(paste0(ReadPath,'/ES2MinSeq.csv'), header = TRUE, sep = ",")[1,5],4,10))
TFranges <- read.csv(paste0(AnalyzePath,'/RFtfbs.csv'), header = TRUE, sep = ",")
csvFIMO <- read.csv(paste0(AnalyzePath,project,'fimo0.1.csv'),sep=',',header=TRUE)
FullTFRaw <- sapply(read.csv(paste0(ReadPath,'/redfly_tfbs.csv'), header = TRUE, sep = ",")[1:27,c(1,5,6)], as.character)
offset <- 49 #offset between start of full ES2 and minimal
TFminNorm <- TFranges
TFminNorm[,3:4] <- TFminNorm[,3:4] - es2Min + 1 + offset
MinMax <- max(TFminNorm[,4])
seqL <- 898 #length of full dmel ES2
origin <- es2Min - offset
TFClean <- data.frame(FullTFRaw) %>%
mutate(start = as.numeric(substr(coordinates,4,10))-origin + 1,
stop = as.numeric(substr(coordinates,13,19))-origin + 1,
name = tolower(substr(name,1,unlist(gregexpr('_',name))-1)),
pValue = 0,
pattern=name) %>%
select(pattern, start, stop, sequence, pValue)
check <- full_join(TFClean,
select(TFminNorm,-X), c("start" = "X2","stop" = "X3")) %>%
arrange(start,stop)
View(check)
frame <- data.frame(1:seqL)
FIMOLong <- csvFIMO %>%
mutate(dummy=TRUE) %>%
left_join(frame %>% mutate(dummy=TRUE)) %>%
filter(start<= X1.seqL, stop>= X1.seqL) %>%
mutate(bp = X1.seqL, tf = as.character(pattern)) %>%
filter(bp <= MinMax, bp >= offset) %>%
group_by(tf, bp) %>%
summarize( minP = min(pValue)) %>%
filter(!(tf %in% c("slp","cad")))
View(FIMOLong)
Es2MinLong <- TFminNorm %>%
mutate(dummy=TRUE) %>%
left_join(frame %>% mutate(dummy=TRUE)) %>%
filter(X2<= X1.seqL, X3>= X1.seqL) %>%
mutate(bp = X1.seqL,
tf = tolower(as.character(X1)),
minP = 0) %>%
distinct(tf,bp,minP)
pVals <- exp(seq(log(.001), log(.1), length.out = 100))
fimoFull <- mutate(FIMOLong, Fbin = 1) %>%
full_join(mutate(Es2MinLong, Mbin = 1), c("tf","bp")) %>%
mutate(minP = ifelse(!is.na(minP.x),minP.x,minP.y)) %>%
select(-minP.y, -minP.x)
View(Es2MinLong)
View(fimoFull)
scoreMat <- vector()
for (val in pVals){
fimo <- mutate(fimoFull,
Fbin = (!is.na(Fbin))*(minP <= val),
Mbin = !is.na(Mbin),
tp = Mbin*Fbin,
fp = Fbin*(Fbin-Mbin)) %>%
group_by(tf) %>%
summarize_each(funs(sum)) %>%
mutate(pVal = val,
ftp = tp/Mbin,
ffp = fp/(fp+tp))
scoreMat <- rbind(scoreMat,fimo)
}
fpLim <- .3 #for minimal enhancer region I'm reasonably confident that REDFLY's
#tfbs coordinates are close to comprehensive. Therefore, to be conservative,
#I will find the pValue for each TF that gives highest tp % while returning
#fewer than 30% fp.
tpLim <- .5
scoresSorted <- arrange(scoreMat,tf,pVal) %>%
filter(ftp >= tpLim) %>%
group_by(tf) %>%
mutate(rank = row_number()) %>%
filter(((ffp <= fpLim)+(rank==1))>=1) %>%
summarize(max = max(ftp)) %>%
inner_join(filter(scoreMat, (ffp <= fpLim)||(rank==1)),
c("tf"="tf", "max"="ftp" )) %>%
group_by(tf) %>%
summarize(pChoice = min(pVal),
ftp = max(max),
ffp = min(ffp))
#take average repressor pvalue for sloppy and average activator (exclude vfl)for caudal
names <- c("slp", "cad")
SlCa <- mutate(scoresSorted, cadFlag = (tf%in%c("bcd","hb"))) %>%
group_by(cadFlag) %>%
summarize(pChoice = mean(pChoice)) %>%
mutate(tf = names[cadFlag+1]) %>%
select(tf,pChoice)
tfPval <- as.data.frame(rbind(SlCa,select(scoresSorted,tf,pChoice)))
View(tfPval)
outFIMO <- left_join(csvFIMO, mutate(
tfPval,tf = factor(tf)), c("pattern"="tf"))
View(outFIMO)
outFIMO <- left_join(csvFIMO, mutate(
tfPval,tf = factor(tf)), c("pattern"="tf")) %>%
filter(pValue <= pChoice)
View(outFIMO)
View(TFClean)
