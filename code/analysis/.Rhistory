write.csv(out,file=paste0(AnalyzePath,project,'SegmentedES2_p',pFilt,'ms',minStretch,'TFBS.csv'))
write.csv(out,file=paste0(AnalyzePath,project,'ms',minStretch,'TFBS.csv'))
bpUnit <- 6 #minimum "meaningful" length scale
minStretch <- bpUnit #nothing shorter than this counts as an independent sequence
#most tfbs are < 10 bp
dfFIMO <- read.csv(paste0(AnalyzePath,project,'TFBSfiltered.csv'),sep=',',header=TRUE)
seqDNA <- unlist(readDNAStringSet(paste0(AnalyzePath,project,'dmelES2.fa')))
seqCharVec <- as.vector(strsplit(tolower(seqDNA),NULL)[[1]])
for(i in 1:nrow(dfFIMO)){
seqCharVec[dfFIMO[i,3]:dfFIMO[i,4]] <- toupper(seqCharVec[dfFIMO[i,3]:dfFIMO[i,4]])
}
seqCASE <- paste0(seqCharVec, collapse='')
segment_seq_func <- dget(paste0(FunPath,"segment_seq_func.R"))
out <-segment_seq_func(seqDNA=seqDNA,seqCASE=seqCASE
,bpUnit=bpUnit,minStretch=minStretch)
View(out)
nchar(gsub('[a,t,g,c]','',seqCASE))/nchar(seqCASE)
fpLim <- .3 #for minimal enhancer region I'm reasonably confident that REDFLY's
#tfbs coordinates are close to comprehensive. Therefore, to be conservative,
#I will find the pValue for each TF that gives highest tp % while returning
#fewer than 50% fp.
tpLim <- .5
scoresSorted <- arrange(scoreMat,tf,pVal) %>%
filter(ftp >= tpLim) %>%
group_by(tf) %>%
mutate(rank = row_number()) %>%
filter(((ffp <= fpLim)+(rank==1))>=1) %>%
summarize(max = max(ftp)) %>%
inner_join(filter(scoreMat, (ffp <= fpLim)||(rank==1)),
c("tf"="tf", "max"="ftp" )) %>%
group_by(tf) %>%
summarize(pChoice = min(pVal),
ftp = max(max),
ffp = min(ffp))
#import and FIMO results and generate annotated ES2 seq
rm(list = ls())
setwd(getwd())
library(Biostrings)
library(dplyr)
source('../utilities/header.R')
#####Project#######
project <- '/ToFIMO/Results_12.01.16/'
#####IMPORTS######
es2Min <- as.numeric(substr(read.csv(paste0(ReadPath,'/ES2MinSeq.csv'), header = TRUE, sep = ",")[1,5],4,10))
TFranges <- read.csv(paste0(AnalyzePath,'/RFtfbs.csv'), header = TRUE, sep = ",")
csvFIMO <- read.csv(paste0(AnalyzePath,project,'fimo0.1.csv'),sep=',',header=TRUE)
FullTFRaw <- sapply(read.csv(paste0(ReadPath,'/redfly_tfbs.csv'), header = TRUE, sep = ",")[1:27,c(1,5,6)], as.character)
#####DEFINE VARIABLES, CLEAN SETS#####
offset <- 49 #offset between start of full ES2 and minimal
TFminNorm <- TFranges
TFminNorm[,3:4] <- TFminNorm[,3:4] - es2Min + 1 + offset
MinMax <- max(TFminNorm[,4])
seqL <- 898 #length of full dmel ES2
origin <- es2Min - offset
TFClean <- data.frame(FullTFRaw) %>%
mutate(start = as.numeric(substr(coordinates,4,10))-origin + 1,
stop = as.numeric(substr(coordinates,13,19))-origin + 1,
name = tolower(substr(name,1,unlist(gregexpr('_',name))-1)),
pValue = 0,
pattern=name) %>%
select(pattern, start, stop, sequence, pValue)
#####confrim that min and full coordinates match#####
check <- full_join(TFClean,
select(TFminNorm,-X), c("start" = "X2","stop" = "X3")) %>%
arrange(start,stop)
#word
frame <- data.frame(1:seqL)
FIMOLong <- csvFIMO %>%
mutate(dummy=TRUE) %>%
left_join(frame %>% mutate(dummy=TRUE)) %>%
filter(start<= X1.seqL, stop>= X1.seqL) %>%
mutate(bp = X1.seqL, tf = as.character(pattern)) %>%
filter(bp <= MinMax, bp >= offset) %>%
group_by(tf, bp) %>%
summarize( minP = min(pValue)) %>%
filter(!(tf %in% c("slp","cad")))
Es2MinLong <- TFminNorm %>%
mutate(dummy=TRUE) %>%
left_join(frame %>% mutate(dummy=TRUE)) %>%
filter(X2<= X1.seqL, X3>= X1.seqL) %>%
mutate(bp = X1.seqL,
tf = tolower(as.character(X1)),
minP = 0) %>%
distinct(tf,bp,minP)
pVals <- exp(seq(log(.001), log(.1), length.out = 100))
fimoFull <- mutate(FIMOLong, Fbin = 1) %>%
full_join(mutate(Es2MinLong, Mbin = 1), c("tf","bp")) %>%
mutate(minP = ifelse(!is.na(minP.x),minP.x,minP.y)) %>%
select(-minP.y, -minP.x)
scoreMat <- vector()
for (val in pVals){
fimo <- mutate(fimoFull,
Fbin = (!is.na(Fbin))*(minP <= val),
Mbin = !is.na(Mbin),
tp = Mbin*Fbin,
fp = Fbin*(Fbin-Mbin)) %>%
group_by(tf) %>%
summarize_each(funs(sum)) %>%
mutate(pVal = val,
ftp = tp/Mbin,
ffp = fp/(fp+tp))
scoreMat <- rbind(scoreMat,fimo)
}
fpLim <- .3 #for minimal enhancer region I'm reasonably confident that REDFLY's
#tfbs coordinates are close to comprehensive. Therefore, to be conservative,
#I will find the pValue for each TF that gives highest tp % while returning
#fewer than 50% fp.
tpLim <- .5
scoresSorted <- arrange(scoreMat,tf,pVal) %>%
filter(ftp >= tpLim) %>%
group_by(tf) %>%
mutate(rank = row_number()) %>%
filter(((ffp <= fpLim)+(rank==1))>=1) %>%
summarize(max = max(ftp)) %>%
inner_join(filter(scoreMat, (ffp <= fpLim)||(rank==1)),
c("tf"="tf", "max"="ftp" )) %>%
group_by(tf) %>%
summarize(pChoice = min(pVal),
ftp = max(max),
ffp = min(ffp))
View(scoresSorted)
#take average repressor pvalue for sloppy and average activator (exclude vfl)for caudal
names <- c("slp", "cad")
SlCa <- mutate(scoresSorted, cadFlag = (tf%in%c("bcd","hb"))) %>%
group_by(cadFlag) %>%
summarize(pChoice = mean(pChoice)) %>%
mutate(tf = names[cadFlag+1]) %>%
select(tf,pChoice)
tfPval <- as.data.frame(rbind(SlCa,select(scoresSorted,tf,pChoice)))
outFIMO <- left_join(csvFIMO, mutate(
tfPval,tf = factor(tf)), c("pattern"="tf")) %>%
filter(pValue <= pChoice) %>%
select(pattern,start,stop,sequence, pValue)
TFBS <- rbind(outFIMO,TFClean)
write.csv(TFBS,file=paste0(AnalyzePath,project,'TFBSfiltered.csv'))
minStretch <- 6*bpUnit #nothing shorter than this counts as an independent sequence
#most tfbs are < 10 bp
dfFIMO <- read.csv(paste0(AnalyzePath,project,'TFBSfiltered.csv'),sep=',',header=TRUE)
seqDNA <- unlist(readDNAStringSet(paste0(AnalyzePath,project,'dmelES2.fa')))
seqCharVec <- as.vector(strsplit(tolower(seqDNA),NULL)[[1]])
for(i in 1:nrow(dfFIMO)){
seqCharVec[dfFIMO[i,3]:dfFIMO[i,4]] <- toupper(seqCharVec[dfFIMO[i,3]:dfFIMO[i,4]])
}
seqCASE <- paste0(seqCharVec, collapse='')
segment_seq_func <- dget(paste0(FunPath,"segment_seq_func.R"))
out <-segment_seq_func(seqDNA=seqDNA,seqCASE=seqCASE
,bpUnit=bpUnit,minStretch=minStretch)
#import and FIMO results and generate annotated ES2 seq
rm(list = ls())
setwd(getwd())
library(Biostrings)
library(dplyr)
source('../utilities/header.R')
project <- '/ToFIMO/Results_12.01.16/'
bpUnit <- 6 #minimum "meaningful" length scale
minStretch <- 6*bpUnit #nothing shorter than this counts as an independent sequence
#most tfbs are < 10 bp
dfFIMO <- read.csv(paste0(AnalyzePath,project,'TFBSfiltered.csv'),sep=',',header=TRUE)
seqDNA <- unlist(readDNAStringSet(paste0(AnalyzePath,project,'dmelES2.fa')))
seqCharVec <- as.vector(strsplit(tolower(seqDNA),NULL)[[1]])
for(i in 1:nrow(dfFIMO)){
seqCharVec[dfFIMO[i,3]:dfFIMO[i,4]] <- toupper(seqCharVec[dfFIMO[i,3]:dfFIMO[i,4]])
}
seqCASE <- paste0(seqCharVec, collapse='')
segment_seq_func <- dget(paste0(FunPath,"segment_seq_func.R"))
out <-segment_seq_func(seqDNA=seqDNA,seqCASE=seqCASE
,bpUnit=bpUnit,minStretch=minStretch)
View(out)
minStretch <- 8*bpUnit #nothing shorter than this counts as an independent sequence
dfFIMO <- read.csv(paste0(AnalyzePath,project,'TFBSfiltered.csv'),sep=',',header=TRUE)
seqDNA <- unlist(readDNAStringSet(paste0(AnalyzePath,project,'dmelES2.fa')))
seqCharVec <- as.vector(strsplit(tolower(seqDNA),NULL)[[1]])
for(i in 1:nrow(dfFIMO)){
seqCharVec[dfFIMO[i,3]:dfFIMO[i,4]] <- toupper(seqCharVec[dfFIMO[i,3]:dfFIMO[i,4]])
}
seqCASE <- paste0(seqCharVec, collapse='')
segment_seq_func <- dget(paste0(FunPath,"segment_seq_func.R"))
out <-segment_seq_func(seqDNA=seqDNA,seqCASE=seqCASE
,bpUnit=bpUnit,minStretch=minStretch)
View(out)
write.csv(tfPval,file=paste0(AnalyzePath,project,'TFBSplimits.csv'))
#import and FIMO results and generate annotated ES2 seq
rm(list = ls())
setwd(getwd())
library(Biostrings)
library(dplyr)
source('../utilities/header.R')
#####Project#######
project <- '/ToFIMO/Results_12.01.16/'
#####IMPORTS######
es2Min <- as.numeric(substr(read.csv(paste0(ReadPath,'/ES2MinSeq.csv'), header = TRUE, sep = ",")[1,5],4,10))
TFranges <- read.csv(paste0(AnalyzePath,'/RFtfbs.csv'), header = TRUE, sep = ",")
csvFIMO <- read.csv(paste0(AnalyzePath,project,'fimo0.1.csv'),sep=',',header=TRUE)
FullTFRaw <- sapply(read.csv(paste0(ReadPath,'/redfly_tfbs.csv'), header = TRUE, sep = ",")[1:27,c(1,5,6)], as.character)
#####DEFINE VARIABLES, CLEAN SETS#####
offset <- 49 #offset between start of full ES2 and minimal
TFminNorm <- TFranges
TFminNorm[,3:4] <- TFminNorm[,3:4] - es2Min + 1 + offset
MinMax <- max(TFminNorm[,4])
seqL <- 898 #length of full dmel ES2
origin <- es2Min - offset
TFClean <- data.frame(FullTFRaw) %>%
mutate(start = as.numeric(substr(coordinates,4,10))-origin + 1,
stop = as.numeric(substr(coordinates,13,19))-origin + 1,
name = tolower(substr(name,1,unlist(gregexpr('_',name))-1)),
pValue = 0,
pattern=name) %>%
select(pattern, start, stop, sequence, pValue)
#####confrim that min and full coordinates match#####
check <- full_join(TFClean,
select(TFminNorm,-X), c("start" = "X2","stop" = "X3")) %>%
arrange(start,stop)
#word
frame <- data.frame(1:seqL)
FIMOLong <- csvFIMO %>%
mutate(dummy=TRUE) %>%
left_join(frame %>% mutate(dummy=TRUE)) %>%
filter(start<= X1.seqL, stop>= X1.seqL) %>%
mutate(bp = X1.seqL, tf = as.character(pattern)) %>%
filter(bp <= MinMax, bp >= offset) %>%
group_by(tf, bp) %>%
summarize( minP = min(pValue)) %>%
filter(!(tf %in% c("slp","cad")))
Es2MinLong <- TFminNorm %>%
mutate(dummy=TRUE) %>%
left_join(frame %>% mutate(dummy=TRUE)) %>%
filter(X2<= X1.seqL, X3>= X1.seqL) %>%
mutate(bp = X1.seqL,
tf = tolower(as.character(X1)),
minP = 0) %>%
distinct(tf,bp,minP)
pVals <- exp(seq(log(.001), log(.1), length.out = 100))
fimoFull <- mutate(FIMOLong, Fbin = 1) %>%
full_join(mutate(Es2MinLong, Mbin = 1), c("tf","bp")) %>%
mutate(minP = ifelse(!is.na(minP.x),minP.x,minP.y)) %>%
select(-minP.y, -minP.x)
scoreMat <- vector()
for (val in pVals){
fimo <- mutate(fimoFull,
Fbin = (!is.na(Fbin))*(minP <= val),
Mbin = !is.na(Mbin),
tp = Mbin*Fbin,
fp = Fbin*(Fbin-Mbin)) %>%
group_by(tf) %>%
summarize_each(funs(sum)) %>%
mutate(pVal = val,
ftp = tp/Mbin,
ffp = fp/(fp+tp))
scoreMat <- rbind(scoreMat,fimo)
}
fpLim <- .3 #for minimal enhancer region I'm reasonably confident that REDFLY's
#tfbs coordinates are close to comprehensive. Therefore, to be conservative,
#I will find the pValue for each TF that gives highest tp % while returning
#fewer than 50% fp.
tpLim <- .5
scoresSorted <- arrange(scoreMat,tf,pVal) %>%
filter(ftp >= tpLim) %>%
group_by(tf) %>%
mutate(rank = row_number()) %>%
filter(((ffp <= fpLim)+(rank==1))>=1) %>%
summarize(max = max(ftp)) %>%
inner_join(filter(scoreMat, (ffp <= fpLim)||(rank==1)),
c("tf"="tf", "max"="ftp" )) %>%
group_by(tf) %>%
summarize(pChoice = min(pVal),
ftp = max(max),
ffp = min(ffp))
#take average repressor pvalue for sloppy and average activator (exclude vfl)for caudal
names <- c("slp", "cad")
SlCa <- mutate(scoresSorted, cadFlag = (tf%in%c("bcd","hb"))) %>%
group_by(cadFlag) %>%
summarize(pChoice = mean(pChoice)) %>%
mutate(tf = names[cadFlag+1]) %>%
select(tf,pChoice)
tfPval <- as.data.frame(rbind(SlCa,select(scoresSorted,tf,pChoice)))
outFIMO <- left_join(csvFIMO, mutate(
tfPval,tf = factor(tf)), c("pattern"="tf")) %>%
filter(pValue <= pChoice) %>%
select(pattern,start,stop,sequence, pValue)
TFBS <- rbind(outFIMO,TFClean)
write.csv(TFBS,file=paste0(AnalyzePath,project,'TFBSfiltered.csv'))
write.csv(tfPval,file=paste0(AnalyzePath,project,'TFBSplimits.csv'))
#import and FIMO results and generate annotated ES2 seq
rm(list = ls())
setwd(getwd())
library(Biostrings)
library(dplyr)
source('../utilities/header.R')
project <- '/ToFIMO/Results_12.01.16/'
bpUnit <- 6 #minimum "meaningful" length scale
minStretch <- 8*bpUnit #nothing shorter than this counts as an independent sequence
#most tfbs are < 10 bp
dfFIMO <- read.csv(paste0(AnalyzePath,project,'TFBSfiltered.csv'),sep=',',header=TRUE)
seqDNA <- unlist(readDNAStringSet(paste0(AnalyzePath,project,'dmelES2.fa')))
seqCharVec <- as.vector(strsplit(tolower(seqDNA),NULL)[[1]])
for(i in 1:nrow(dfFIMO)){
seqCharVec[dfFIMO[i,3]:dfFIMO[i,4]] <- toupper(seqCharVec[dfFIMO[i,3]:dfFIMO[i,4]])
}
seqCASE <- paste0(seqCharVec, collapse='')
segment_seq_func <- dget(paste0(FunPath,"segment_seq_func.R"))
out <-segment_seq_func(seqDNA=seqDNA,seqCASE=seqCASE
,bpUnit=bpUnit,minStretch=minStretch)
write(seqCASE, file = paste0(AnalyzePath,project,'dmel_ES2Case.txt'))
write.csv(out,file=paste0(AnalyzePath,project,'ms',minStretch,'TFBS.csv'))
#import and FIMO results and generate annotated ES2 seq
rm(list = ls())
setwd(getwd())
library(Biostrings)
library(dplyr)
source('../utilities/header.R')
project <- '/ToFIMO/Results_12.01.16/'
bpUnit <- 6 #minimum "meaningful" length scale
minStretch <- bpUnit #nothing shorter than this counts as an independent sequence
#most tfbs are < 10 bp
dfFIMO <- read.csv(paste0(AnalyzePath,project,'TFBSfiltered.csv'),sep=',',header=TRUE)
seqDNA <- unlist(readDNAStringSet(paste0(AnalyzePath,project,'dmelES2.fa')))
seqCharVec <- as.vector(strsplit(tolower(seqDNA),NULL)[[1]])
for(i in 1:nrow(dfFIMO)){
seqCharVec[dfFIMO[i,3]:dfFIMO[i,4]] <- toupper(seqCharVec[dfFIMO[i,3]:dfFIMO[i,4]])
}
seqCASE <- paste0(seqCharVec, collapse='')
segment_seq_func <- dget(paste0(FunPath,"segment_seq_func.R"))
out <-segment_seq_func(seqDNA=seqDNA,seqCASE=seqCASE
,bpUnit=bpUnit,minStretch=minStretch)
write(seqCASE, file = paste0(AnalyzePath,project,'dmel_ES2Case.txt'))
write.csv(out,file=paste0(AnalyzePath,project,'ms',minStretch,'TFBS.csv'))
#import and FIMO results and generate annotated ES2 seq
rm(list = ls())
setwd(getwd())
library(Biostrings)
library(dplyr)
source('../utilities/header.R')
#parameters used to generate ref files
consLim <- .8
RHO <- .3
project <- '/ToFIMO/Results_12.01.16/'
seqCASE <- as.character(unlist(read.csv(paste0(AnalyzePath,project,
'dmel_es2CASECons_rho',RHO,'cl',consLim,'.txt'),header=FALSE)))
dmeles2 <- DNAString(seqCASE)
#####CALL SEGEMENTATION FUNC#####
segment_seq_func <- dget(paste0(FunPath,"segment_seq_func.R"))
bpUnit <- 6
minStretch <- bpUnit #not very sensitive to param val
out <-segment_seq_func(seqDNA=dmeles2,seqCASE=seqCASE
,bpUnit=bpUnit,minStretch=minStretch)
write.csv(out,file=paste0(AnalyzePath,project,'SegmentedES2_c',consLim,'ms',minStretch,'CONS.csv'))
minStretch <- 8*bpUnit #not very sensitive to param val
out <-segment_seq_func(seqDNA=dmeles2,seqCASE=seqCASE
,bpUnit=bpUnit,minStretch=minStretch)
minStretch <- 6*bpUnit #not very sensitive to param val
out <-segment_seq_func(seqDNA=dmeles2,seqCASE=seqCASE
,bpUnit=bpUnit,minStretch=minStretch)
write.csv(out,file=paste0(AnalyzePath,project,'SegmentedES2_c',consLim,'ms',minStretch,'CONS.csv'))
#import and FIMO results and generate annotated ES2 seq
rm(list = ls())
setwd(getwd())
library(Biostrings)
library(dplyr)
source('../utilities/header.R')
project <- '/ToFIMO/Results_12.01.16/'
bpUnit <- 6 #minimum "meaningful" length scale
minStretch <- 6*bpUnit #nothing shorter than this counts as an independent sequence
#most tfbs are < 10 bp
dfFIMO <- read.csv(paste0(AnalyzePath,project,'TFBSfiltered.csv'),sep=',',header=TRUE)
seqDNA <- unlist(readDNAStringSet(paste0(AnalyzePath,project,'dmelES2.fa')))
seqCharVec <- as.vector(strsplit(tolower(seqDNA),NULL)[[1]])
for(i in 1:nrow(dfFIMO)){
seqCharVec[dfFIMO[i,3]:dfFIMO[i,4]] <- toupper(seqCharVec[dfFIMO[i,3]:dfFIMO[i,4]])
}
seqCASE <- paste0(seqCharVec, collapse='')
segment_seq_func <- dget(paste0(FunPath,"segment_seq_func.R"))
out <-segment_seq_func(seqDNA=seqDNA,seqCASE=seqCASE
,bpUnit=bpUnit,minStretch=minStretch)
write(seqCASE, file = paste0(AnalyzePath,project,'dmel_ES2Case.txt'))
write.csv(out,file=paste0(AnalyzePath,project,'ms',minStretch,'TFBS.csv'))
#Variational Approach to minimize edge conflicts
rm(list = ls())
setwd("C:/Users/Nicholas/Documents/GitHub/synth_es2/code/analysis")
library(Biostrings)
library(clue)
source('../utilities/header.R')
source(paste0(FunPath,'utilities.R'))
project <- 'Results_12.01.16'
hungarian_solve_gaps_func <- dget(paste0(FunPath,"hungarian_solve_gaps_func.R"))
hungarian_shuffle_search <- dget(paste0(FunPath,"hung_shuffle_search.R"))
files = c("ms6TFBS", "ms36TFBS","c0.8ms6CONS","c0.8ms36CONS")
# "p0.005ms6TFBS", "p0.005ms18TFBS", "p0.005ms24TFBS")
#Define vars
bpUnit = 6
ITER = 100
ptm <- proc.time()
for (file in files){
csvSEG <- read.csv(paste0(AnalyzePath,'/ToFIMO/',project,'/','SegmentedES2_',file,'.csv'),sep=',',header=TRUE)
results <- hungarian_shuffle_search(iter=ITER,segDF=csvSEG,bpUnit=6)
minScore <- min(results[[3]])
minID <- min(which(results[[3]]==minScore))
BestSeq <- results[[2]][minID,]
seqChar <- paste0(csvSEG[BestSeq,4],collapse='')
seqDNA <- DNAStringSet(seqChar)
seqOut <- csvSEG[BestSeq,][,1:4]
write(seqChar, file = paste0(OutPath,'/ResultsTxt/',file,'_iter_',ITER,'_',project,'.txt'))
writeXStringSet(seqDNA,file=paste0(OutPath,'/ResultsFasta/',file,'_iter_',ITER,'_',project,'.fa'))
write.csv(seqOut,file=paste0(OutPath,'/ResultsCsv/',file,'_iter_',ITER,'_',project,'.csv'))
write.csv(as.vector(results[[3]]),file=paste0(OutPath,'/ResultsCsv/',file,'_iter_',ITER,'_',project,'scores.csv'))
}
proc.time() - ptm
#import and FIMO results and generate annotated ES2 seq
rm(list = ls())
setwd(getwd())
library(Biostrings)
library(dplyr)
source('../utilities/header.R')
project <- '/ToFIMO/Results_12.01.16/'
bpUnit <- 6 #minimum "meaningful" length scale
minStretch <- 6*bpUnit #nothing shorter than this counts as an independent sequence
#most tfbs are < 10 bp
dfFIMO <- read.csv(paste0(AnalyzePath,project,'TFBSfiltered.csv'),sep=',',header=TRUE)
seqDNA <- unlist(readDNAStringSet(paste0(AnalyzePath,project,'dmelES2.fa')))
seqCharVec <- as.vector(strsplit(tolower(seqDNA),NULL)[[1]])
for(i in 1:nrow(dfFIMO)){
seqCharVec[dfFIMO[i,3]:dfFIMO[i,4]] <- toupper(seqCharVec[dfFIMO[i,3]:dfFIMO[i,4]])
}
seqCASE <- paste0(seqCharVec, collapse='')
segment_seq_func <- dget(paste0(FunPath,"segment_seq_func.R"))
out <-segment_seq_func(seqDNA=seqDNA,seqCASE=seqCASE
,bpUnit=bpUnit,minStretch=minStretch)
write(seqCASE, file = paste0(AnalyzePath,project,'dmel_ES2Case.txt'))
write.csv(out,file=paste0(AnalyzePath,project,'SegmentedES2_ms',minStretch,'TFBS.csv'))
#import and FIMO results and generate annotated ES2 seq
rm(list = ls())
setwd(getwd())
library(Biostrings)
library(dplyr)
source('../utilities/header.R')
project <- '/ToFIMO/Results_12.01.16/'
bpUnit <- 6 #minimum "meaningful" length scale
minStretch <- bpUnit #nothing shorter than this counts as an independent sequence
#most tfbs are < 10 bp
dfFIMO <- read.csv(paste0(AnalyzePath,project,'TFBSfiltered.csv'),sep=',',header=TRUE)
seqDNA <- unlist(readDNAStringSet(paste0(AnalyzePath,project,'dmelES2.fa')))
seqCharVec <- as.vector(strsplit(tolower(seqDNA),NULL)[[1]])
for(i in 1:nrow(dfFIMO)){
seqCharVec[dfFIMO[i,3]:dfFIMO[i,4]] <- toupper(seqCharVec[dfFIMO[i,3]:dfFIMO[i,4]])
}
seqCASE <- paste0(seqCharVec, collapse='')
segment_seq_func <- dget(paste0(FunPath,"segment_seq_func.R"))
out <-segment_seq_func(seqDNA=seqDNA,seqCASE=seqCASE
,bpUnit=bpUnit,minStretch=minStretch)
write(seqCASE, file = paste0(AnalyzePath,project,'dmel_ES2Case.txt'))
write.csv(out,file=paste0(AnalyzePath,project,'SegmentedES2_ms',minStretch,'TFBS.csv'))
#Variational Approach to minimize edge conflicts
rm(list = ls())
setwd("C:/Users/Nicholas/Documents/GitHub/synth_es2/code/analysis")
library(Biostrings)
library(clue)
source('../utilities/header.R')
source(paste0(FunPath,'utilities.R'))
project <- 'Results_12.01.16'
hungarian_solve_gaps_func <- dget(paste0(FunPath,"hungarian_solve_gaps_func.R"))
hungarian_shuffle_search <- dget(paste0(FunPath,"hung_shuffle_search.R"))
files = c("ms6TFBS", "ms36TFBS","c0.8ms6CONS","c0.8ms36CONS")
# "p0.005ms6TFBS", "p0.005ms18TFBS", "p0.005ms24TFBS")
#Define vars
bpUnit = 6
ITER = 100
ptm <- proc.time()
for (file in files){
csvSEG <- read.csv(paste0(AnalyzePath,'/ToFIMO/',project,'/','SegmentedES2_',file,'.csv'),sep=',',header=TRUE)
results <- hungarian_shuffle_search(iter=ITER,segDF=csvSEG,bpUnit=6)
minScore <- min(results[[3]])
minID <- min(which(results[[3]]==minScore))
BestSeq <- results[[2]][minID,]
seqChar <- paste0(csvSEG[BestSeq,4],collapse='')
seqDNA <- DNAStringSet(seqChar)
seqOut <- csvSEG[BestSeq,][,1:4]
write(seqChar, file = paste0(OutPath,'/ResultsTxt/',file,'_iter_',ITER,'_',project,'.txt'))
writeXStringSet(seqDNA,file=paste0(OutPath,'/ResultsFasta/',file,'_iter_',ITER,'_',project,'.fa'))
write.csv(seqOut,file=paste0(OutPath,'/ResultsCsv/',file,'_iter_',ITER,'_',project,'.csv'))
write.csv(as.vector(results[[3]]),file=paste0(OutPath,'/ResultsCsv/',file,'_iter_',ITER,'_',project,'scores.csv'))
}
proc.time() - ptm
files = c("c0.8ms6CONS","c0.8ms36CONS","ms6TFBS", "ms36TFBS"
)
for (file in files){
seqResults <- read.csv(file=paste0(OutPath,'/ResultsCsv/',file,'_iter_',ITER,'_',project,'.csv'))
mInd1 <- gregexpr('ms',file)[[1]]+2
mInd2 <- gregexpr('\\d[A-Z]',file)
tInd <- gregexpr('[A-Z]{4,}',file)[[1]]
minStretch <- substr(file,mInd1,mInd2)
type <- substr(file,tInd,tInd+3)
plotArray <- vector()
index <- 1
for (i in 1:nrow(seqResults)){
a <- rep(0,seqResults[i,4]-seqResults[i,3]+1)
consInd <- gregexpr('[A-Z]',seqResults[i,5])[[1]]
a[consInd] <- 1
seq <- cbind(factor(a),seqResults[i,1],seqResults[i,3]:seqResults[i,4]
,index:(index+seqResults[i,4]-seqResults[i,3]))
index <- index+ seqResults[i,4]-seqResults[i,3]+ 1
plotArray <- rbind(plotArray,seq)
}
ToPlot <- data.frame(rbind(plotArray[,1:4],cbind(plotArray[,1:3],plotArray[,3])))
ToPlot[,2] <- factor(as.character(ToPlot[,2]))
ToPlot <- ToPlot[ToPlot[,4]%%2==1,]
c <- ggplot(ToPlot, aes(x=X4, y=X3,color=X2, alpha = X1))
c <- c + geom_point(aes())+ theme(legend.position="none")
c <- c + labs(list(title = paste0('Original vs. Shuffled ES2:'),
subtitle= paste0('Minimum Permitted Stretch: '
,minStretch, ' Type:',type), x = "bp (from)", y = "bp (to)"))
c
ggsave(paste0(OutPath,'/plots/',project,'_',file,'.pdf'))
}
