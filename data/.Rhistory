iter <- 2
for (i in 1:inc){
accept <- 0
for(j in 1:sub){
es2New <- sub_seq_fun(seq=es2Old,ref=es2,subVec=sampVec,nsub=NSUB,tol=TOL)
ScoreNew <- pwmScoreDriver_fun(SEQ=es2New,DRIVER=TFsumm)
deltaNew <- sum(wtsPMW*(ScoreNew-es2Scores)^2)
if (deltaNew < deltaOld){
ScoreOld <- ScoreNew
deltaOld <- deltaNew
es2Old <- es2New
delta[iter] <- deltaOld
accept <- accept + 1
iter <- iter + 1
}
}
accept[i] <- accept/sub
}
#given a matrix of PWMs, calculate normalized joint score
rm(list = ls())
library(dplyr)
library(Biostrings)
library(ggplot2)
#library(reshape)
setwd('C:/Users/Nicholas/Documents/GitHub/synth_es2/data/')
InPath <- 'intermediate/'
WritePath <- './out/'
FunPath <- 'C:/Users/Nicholas/Documents/GitHub/synth_es2/analysis/functions/'
annotate_tfbs_fun <- dget(paste0(FunPath,"annotate_tfbs_fun.R"))
pwmWeights_fun <- dget(paste0(FunPath,"pwmWeights_fun.R"))
pwmScoreDriver_fun <- dget(paste0(FunPath,"pwmScoreDriver_fun.R"))
pwmScore_fun <- dget(paste0(FunPath,"pwmScore_fun.R")) #called inside pwmScoreDriver_fun
sub_seq_fun <- dget(paste0(FunPath,"sub_seq_fun.R"))
#####Read in PWM Matrix#####
MasterPWM <- read.table(file = paste0(InPath,'MasterPWM.csv'), header = TRUE, sep = ',')
TFsumm <- as.data.frame(group_by(MasterPWM,TF,ID)%>%
summarize())
TFnames <- unique(TFsumm[,1])
#####Read in ES2 Matrix######
es2csv <- read.csv('./in/redfly/ES2MinSeq.csv', header = TRUE, sep = ",")
TFranges <- read.csv('./intermediate/TFranges.csv', header = TRUE, sep = ",")[,2:3]
#create es2 seq char
es2Char <- as.character(es2csv[1,6])
#call tfbs annotation function
es2AnnoChar <- gsub('F','-',annotate_tfbs_fun(seq=es2Char,tfbs=TFranges))
es2Anno <- DNAString(es2AnnoChar)
es2 <- DNAString(es2Char)
#Calculate weight and es2 ref matrices that will remain constant throughout iteration
wtsPMW <- pwmWeights_fun(SEQ=es2,DRIVER=TFsumm)
es2Scores <- pwmScoreDriver_fun(SEQ=es2,DRIVER=TFsumm)
compSet <- DNAStringSet(c(es2,es2Anno))
sampVec <- as.vector(gregexpr('[A,T,G,C]',es2Anno)[[1]])
sampSeed <- strsplit(es2Char,NULL)[[1]]
charVec <- c("A","G","C","T")
sampMat<- matrix(ncol=4,nrow=length(sampSeed))
#make sure es2 bp is always in same position in samp mat
for (i in 1:length(sampSeed)){
sampMat[i,] <- append(sampSeed[i],charVec[charVec!=sampSeed[i]])
}
es2Scrambled <- es2
es2Scrambled[sampVec] <- strsplit(sample(charVec,length(sampVec),replace=TRUE),NULL)[[1]]
inc <- 3 #routines
sub <- 10 #subroutines
NSUB <- 10 #substitutions per subroutine
TOL <-.25
delta <- vector()
dist <- vector()
accept <- vector()
es2Old <- es2Scrambled
ScoreOld <- pwmScoreDriver_fun(SEQ=es2Old,DRIVER=TFsumm)
deltaOld <- sum(wtsPMW*(ScoreOld-es2Scores)^2)
delta[1] <- deltaOld
iter <- 2
for (i in 1:inc){
accept <- 0
for(j in 1:sub){
es2New <- sub_seq_fun(seq=es2Old,ref=es2,subVec=sampVec,nsub=NSUB,tol=TOL)
ScoreNew <- pwmScoreDriver_fun(SEQ=es2New,DRIVER=TFsumm)
deltaNew <- sum(wtsPMW*(ScoreNew-es2Scores)^2)
if (deltaNew < deltaOld){
ScoreOld <- ScoreNew
deltaOld <- deltaNew
es2Old <- es2New
delta[iter] <- deltaOld
accept <- accept + 1
iter <- iter + 1
}
}
accept[i] <- accept/sub
}
accept
delta
sub <- 2 #subroutines
delta <- vector()
dist <- vector()
accept <- vector()
es2Old <- es2Scrambled
ScoreOld <- pwmScoreDriver_fun(SEQ=es2Old,DRIVER=TFsumm)
deltaOld <- sum(wtsPMW*(ScoreOld-es2Scores)^2)
delta[1] <- deltaOld
iter <- 2
accept
inc <- 3 #routines
sub <- 2 #subroutines
NSUB <- 10 #substitutions per subroutine
TOL <-.25
delta <- vector()
dist <- vector()
accept <- vector()
es2Old <- es2Scrambled
ScoreOld <- pwmScoreDriver_fun(SEQ=es2Old,DRIVER=TFsumm)
deltaOld <- sum(wtsPMW*(ScoreOld-es2Scores)^2)
delta[1] <- deltaOld
iter <- 2
for (i in 1:inc){
acc <- 0
for(j in 1:sub){
es2New <- sub_seq_fun(seq=es2Old,ref=es2,subVec=sampVec,nsub=NSUB,tol=TOL)
ScoreNew <- pwmScoreDriver_fun(SEQ=es2New,DRIVER=TFsumm)
deltaNew <- sum(wtsPMW*(ScoreNew-es2Scores)^2)
if (deltaNew < deltaOld){
ScoreOld <- ScoreNew
deltaOld <- deltaNew
es2Old <- es2New
delta[iter] <- deltaOld
acc <- acc + 1
iter <- iter + 1
}
}
accept[i] <- acc/sub
}
accept
dist <- stringDist(c(paste0(seq),paste0(ref)), method = "hamming",
ignoreCase = FALSE, diag = FALSE, upper = FALSE)[1]
dist <- stringDist(c(paste0(es2),paste0(es2New)), method = "hamming",
ignoreCase = FALSE, diag = FALSE, upper = FALSE)[1]
inc <- 3 #routines
sub <- 2 #subroutines
NSUB <- 10 #substitutions per subroutine
TOL <-.25
delta <- vector()
dist <- vector()
accept <- vector()
es2Old <- es2Scrambled
ScoreOld <- pwmScoreDriver_fun(SEQ=es2Old,DRIVER=TFsumm)
deltaOld <- sum(wtsPMW*(ScoreOld-es2Scores)^2)
delta[1] <- deltaOld
dist[1] <-stringDist(c(paste0(es2),paste0(es2Old)), method = "hamming",
diag = FALSE, upper = FALSE)[1]
iter <- 2
for (i in 1:inc){
acc <- 0
for(j in 1:sub){
es2New <- sub_seq_fun(seq=es2Old,ref=es2,subVec=sampVec,nsub=NSUB,tol=TOL)
ScoreNew <- pwmScoreDriver_fun(SEQ=es2New,DRIVER=TFsumm)
deltaNew <- sum(wtsPMW*(ScoreNew-es2Scores)^2)
if (deltaNew < deltaOld){
ScoreOld <- ScoreNew
deltaOld <- deltaNew
es2Old <- es2New
delta[iter] <- deltaOld
dist(iter) <- stringDist(c(paste0(es2),paste0(es2New)), method = "hamming",
diag = FALSE, upper = FALSE)[1]
acc <- acc + 1
iter <- iter + 1
}
}
accept[i] <- acc/sub
}
inc <- 3 #routines
sub <- 2 #subroutines
NSUB <- 10 #substitutions per subroutine
TOL <-.25
delta <- vector()
dist <- vector()
accept <- vector()
es2Old <- es2Scrambled
ScoreOld <- pwmScoreDriver_fun(SEQ=es2Old,DRIVER=TFsumm)
deltaOld <- sum(wtsPMW*(ScoreOld-es2Scores)^2)
delta[1] <- deltaOld
dist[1] <-stringDist(c(paste0(es2),paste0(es2Old)), method = "hamming",
diag = FALSE, upper = FALSE)[1]
iter <- 2
for (i in 1:inc){
acc <- 0
for(j in 1:sub){
es2New <- sub_seq_fun(seq=es2Old,ref=es2,subVec=sampVec,nsub=NSUB,tol=TOL)
ScoreNew <- pwmScoreDriver_fun(SEQ=es2New,DRIVER=TFsumm)
deltaNew <- sum(wtsPMW*(ScoreNew-es2Scores)^2)
if (deltaNew < deltaOld){
ScoreOld <- ScoreNew
deltaOld <- deltaNew
es2Old <- es2New
delta[iter] <- deltaOld
dist[iter] <- stringDist(c(paste0(es2),paste0(es2New)), method = "hamming",
diag = FALSE, upper = FALSE)[1]
acc <- acc + 1
iter <- iter + 1
}
}
accept[i] <- acc/sub
}
dist
#given a matrix of PWMs, calculate normalized joint score
rm(list = ls())
library(dplyr)
library(Biostrings)
library(ggplot2)
#library(reshape)
setwd('C:/Users/Nicholas/Documents/GitHub/synth_es2/data/')
InPath <- 'intermediate/'
WritePath <- './out/'
FunPath <- 'C:/Users/Nicholas/Documents/GitHub/synth_es2/analysis/functions/'
annotate_tfbs_fun <- dget(paste0(FunPath,"annotate_tfbs_fun.R"))
pwmWeights_fun <- dget(paste0(FunPath,"pwmWeights_fun.R"))
pwmScoreDriver_fun <- dget(paste0(FunPath,"pwmScoreDriver_fun.R"))
pwmScore_fun <- dget(paste0(FunPath,"pwmScore_fun.R")) #called inside pwmScoreDriver_fun
sub_seq_fun <- dget(paste0(FunPath,"sub_seq_fun.R"))
#####Read in PWM Matrix#####
MasterPWM <- read.table(file = paste0(InPath,'MasterPWM.csv'), header = TRUE, sep = ',')
TFsumm <- as.data.frame(group_by(MasterPWM,TF,ID)%>%
summarize())
TFnames <- unique(TFsumm[,1])
#####Read in ES2 Matrix######
es2csv <- read.csv('./in/redfly/ES2MinSeq.csv', header = TRUE, sep = ",")
TFranges <- read.csv('./intermediate/TFranges.csv', header = TRUE, sep = ",")[,2:3]
#create es2 seq char
es2Char <- as.character(es2csv[1,6])
#call tfbs annotation function
es2AnnoChar <- gsub('F','-',annotate_tfbs_fun(seq=es2Char,tfbs=TFranges))
es2Anno <- DNAString(es2AnnoChar)
es2 <- DNAString(es2Char)
#Calculate weight and es2 ref matrices that will remain constant throughout iteration
wtsPMW <- pwmWeights_fun(SEQ=es2,DRIVER=TFsumm)
es2Scores <- pwmScoreDriver_fun(SEQ=es2,DRIVER=TFsumm)
compSet <- DNAStringSet(c(es2,es2Anno))
sampVec <- as.vector(gregexpr('[A,T,G,C]',es2Anno)[[1]])
sampSeed <- strsplit(es2Char,NULL)[[1]]
charVec <- c("A","G","C","T")
sampMat<- matrix(ncol=4,nrow=length(sampSeed))
#make sure es2 bp is always in same position in samp mat
for (i in 1:length(sampSeed)){
sampMat[i,] <- append(sampSeed[i],charVec[charVec!=sampSeed[i]])
}
es2Scrambled <- es2
es2Scrambled[sampVec] <- strsplit(sample(charVec,length(sampVec),replace=TRUE),NULL)[[1]]
inc <- 20 #routines
sub <- 10 #subroutines
NSUB <- 10 #substitutions per subroutine
TOL <-.25
delta <- vector()
dist <- vector()
accept <- vector()
es2Old <- es2Scrambled
ScoreOld <- pwmScoreDriver_fun(SEQ=es2Old,DRIVER=TFsumm)
deltaOld <- sum(wtsPMW*(ScoreOld-es2Scores)^2)
delta[1] <- deltaOld
dist[1] <-stringDist(c(paste0(es2),paste0(es2Old)), method = "hamming",
diag = FALSE, upper = FALSE)[1]
iter <- 2
for (i in 1:inc){
acc <- 0
for(j in 1:sub){
es2New <- sub_seq_fun(seq=es2Old,ref=es2,subVec=sampVec,nsub=NSUB,tol=TOL)
ScoreNew <- pwmScoreDriver_fun(SEQ=es2New,DRIVER=TFsumm)
deltaNew <- sum(wtsPMW*(ScoreNew-es2Scores)^2)
if (deltaNew < deltaOld){
ScoreOld <- ScoreNew
deltaOld <- deltaNew
es2Old <- es2New
delta[iter] <- deltaOld
dist[iter] <- stringDist(c(paste0(es2),paste0(es2New)), method = "hamming",
diag = FALSE, upper = FALSE)[1]
acc <- acc + 1
iter <- iter + 1
}
}
accept[i] <- acc/sub
}
sub_seq_fun <- dget(paste0(FunPath,"sub_seq_fun.R"))
inc <- 20 #routines
sub <- 10 #subroutines
NSUB <- 10 #substitutions per subroutine
TOL <-.25
delta <- vector()
dist <- vector()
accept <- vector()
es2Old <- es2Scrambled
ScoreOld <- pwmScoreDriver_fun(SEQ=es2Old,DRIVER=TFsumm)
deltaOld <- sum(wtsPMW*(ScoreOld-es2Scores)^2)
delta[1] <- deltaOld
dist[1] <-stringDist(c(paste0(es2),paste0(es2Old)), method = "hamming",
diag = FALSE, upper = FALSE)[1]
iter <- 2
for (i in 1:inc){
acc <- 0
for(j in 1:sub){
es2New <- sub_seq_fun(seq=es2Old,ref=es2,subVec=sampVec,nsub=NSUB,tol=TOL)
ScoreNew <- pwmScoreDriver_fun(SEQ=es2New,DRIVER=TFsumm)
deltaNew <- sum(wtsPMW*(ScoreNew-es2Scores)^2)
if (deltaNew < deltaOld){
ScoreOld <- ScoreNew
deltaOld <- deltaNew
es2Old <- es2New
delta[iter] <- deltaOld
dist[iter] <- stringDist(c(paste0(es2),paste0(es2New)), method = "hamming",
diag = FALSE, upper = FALSE)[1]
acc <- acc + 1
iter <- iter + 1
}
}
accept[i] <- acc/sub
}
accept
delta
dist
accept[1]
deltaNew
#####
compSet <- DNAStringSet(c(es2,es2Anno))
sampVec <- as.vector(gregexpr('[A,T,G,C]',es2Anno)[[1]])
sampSeed <- strsplit(es2Char,NULL)[[1]]
charVec <- c("A","G","C","T")
sampMat<- matrix(ncol=4,nrow=length(sampSeed))
#make sure es2 bp is always in same position in samp mat
for (i in 1:length(sampSeed)){
sampMat[i,] <- append(sampSeed[i],charVec[charVec!=sampSeed[i]])
}
es2Scrambled <- es2
es2Scrambled[sampVec] <- strsplit(sample(charVec,length(sampVec),replace=TRUE),NULL)[[1]]
inc <- 20 #routines
sub <- 10 #subroutines
NSUB <- 10 #substitutions per subroutine
TOL <-.25
delta <- vector()
dist <- vector()
accept <- vector()
es2Old <- es2Scrambled
ScoreOld <- pwmScoreDriver_fun(SEQ=es2Old,DRIVER=TFsumm)
deltaOld <- sum(wtsPMW*(ScoreOld-es2Scores)^2)
delta[1] <- deltaOld
dist[1] <-stringDist(c(paste0(es2),paste0(es2Old)), method = "hamming",
diag = FALSE, upper = FALSE)[1]
iter <- 2
for (i in 1:inc){
acc <- 0
for(j in 1:sub){
es2New <- sub_seq_fun(seq=es2Old,ref=es2,subVec=sampVec,nsub=NSUB,tol=TOL)
ScoreNew <- pwmScoreDriver_fun(SEQ=es2New,DRIVER=TFsumm)
deltaNew <- sum(wtsPMW*(ScoreNew-es2Scores)^2)
if (deltaNew < deltaOld){
ScoreOld <- ScoreNew
deltaOld <- deltaNew
es2Old <- es2New
delta[iter] <- deltaOld
dist[iter] <- stringDist(c(paste0(es2),paste0(es2New)), method = "hamming",
diag = FALSE, upper = FALSE)[1]
acc <- acc + 1
iter <- iter + 1
}
}
accept[i] <- acc/sub
}
accept
delta
deltaNew
inc <- 2 #routines
sub <- 1 #subroutines
NSUB <- 5 #substitutions per subroutine
TOL <-.5
delta <- vector()
dist <- vector()
accept <- vector()
es2Old <- es2Scrambled
ScoreOld <- pwmScoreDriver_fun(SEQ=es2Old,DRIVER=TFsumm)
deltaOld <- sum(wtsPMW*(ScoreOld-es2Scores)^2)
delta[1] <- deltaOld
dist[1] <-stringDist(c(paste0(es2),paste0(es2Old)), method = "hamming",
diag = FALSE, upper = FALSE)[1]
iter <- 2
for (i in 1:inc){
acc <- 0
for(j in 1:sub){
es2New <- sub_seq_fun(seq=es2Old,ref=es2,subVec=sampVec,nsub=NSUB,tol=TOL)
ScoreNew <- pwmScoreDriver_fun(SEQ=es2New,DRIVER=TFsumm)
deltaNew <- sum(wtsPMW*(ScoreNew-es2Scores)^2)
if (deltaNew < deltaOld){
ScoreOld <- ScoreNew
deltaOld <- deltaNew
es2Old <- es2New
acc <- acc + 1
}
delta[iter] <- deltaOld
dist[iter] <- stringDist(c(paste0(es2),paste0(es2New)), method = "hamming",
diag = FALSE, upper = FALSE)[1]
iter <- iter + 1
}
accept[i] <- acc/sub
}
delta
dist
es2Scrambled <- es2
es2Scrambled[sampVec] <- strsplit(sample(charVec,length(sampVec),replace=TRUE),NULL)[[1]]
inc <- 2 #routines
sub <- 1 #subroutines
NSUB <- 5 #substitutions per subroutine
TOL <-.5
delta <- vector()
distance <- vector()
accept <- vector()
es2Old <- es2Scrambled
ScoreOld <- pwmScoreDriver_fun(SEQ=es2Old,DRIVER=TFsumm)
deltaOld <- sum(wtsPMW*(ScoreOld-es2Scores)^2)
delta[1] <- deltaOld
distance[1] <-stringDist(c(paste0(es2),paste0(es2Old)), method = "hamming",
diag = FALSE, upper = FALSE)[1]
iter <- 2
for (i in 1:inc){
acc <- 0
for(j in 1:sub){
es2New <- sub_seq_fun(seq=es2Old,ref=es2,subVec=sampVec,nsub=NSUB,tol=TOL)
ScoreNew <- pwmScoreDriver_fun(SEQ=es2New,DRIVER=TFsumm)
deltaNew <- sum(wtsPMW*(ScoreNew-es2Scores)^2)
if (deltaNew < deltaOld){
ScoreOld <- ScoreNew
deltaOld <- deltaNew
es2Old <- es2New
acc <- acc + 1
}
delta[iter] <- deltaOld
distance[iter] <- stringDist(c(paste0(es2),paste0(es2New)), method = "hamming",
diag = FALSE, upper = FALSE)[1]
iter <- iter + 1
}
accept[i] <- acc/sub
}
distance
delta
es2Scrambled <- es2
es2Scrambled[sampVec] <- strsplit(sample(charVec,length(sampVec),replace=TRUE),NULL)[[1]]
inc <- 100 #routines
sub <- 10 #subroutines
NSUB <- 5 #substitutions per subroutine
TOL <-.5
delta <- vector()
distance <- vector()
accept <- vector()
es2Old <- es2Scrambled
ScoreOld <- pwmScoreDriver_fun(SEQ=es2Old,DRIVER=TFsumm)
deltaOld <- sum(wtsPMW*(ScoreOld-es2Scores)^2)
delta[1] <- deltaOld
distance[1] <-1-(stringDist(c(paste0(es2),paste0(es2Old)), method = "hamming",
diag = FALSE, upper = FALSE)[1])/length)/sampVec
iter <- 2
for (i in 1:inc){
acc <- 0
for(j in 1:sub){
es2New <- sub_seq_fun(seq=es2Old,ref=es2,subVec=sampVec,nsub=NSUB,tol=TOL)
ScoreNew <- pwmScoreDriver_fun(SEQ=es2New,DRIVER=TFsumm)
deltaNew <- sum(wtsPMW*(ScoreNew-es2Scores)^2)
if (deltaNew < deltaOld){
ScoreOld <- ScoreNew
deltaOld <- deltaNew
es2Old <- es2New
acc <- acc + 1
}
delta[iter] <- deltaOld
distance[iter] <- (stringDist(c(paste0(es2),paste0(es2Old)), method = "hamming",
diag = FALSE, upper = FALSE)[1])/sampVec
iter <- iter + 1
}
accept[i] <- acc/sub
}
es2Scrambled <- es2
es2Scrambled[sampVec] <- strsplit(sample(charVec,length(sampVec),replace=TRUE),NULL)[[1]]
inc <- 100 #routines
sub <- 10 #subroutines
NSUB <- 5 #substitutions per subroutine
TOL <-.5
delta <- vector()
distance <- vector()
accept <- vector()
es2Old <- es2Scrambled
ScoreOld <- pwmScoreDriver_fun(SEQ=es2Old,DRIVER=TFsumm)
deltaOld <- sum(wtsPMW*(ScoreOld-es2Scores)^2)
delta[1] <- deltaOld
distance[1] <-1-(stringDist(c(paste0(es2),paste0(es2Old)), method = "hamming",
diag = FALSE, upper = FALSE)[1])/length(sampVec)
iter <- 2
for (i in 1:inc){
acc <- 0
for(j in 1:sub){
es2New <- sub_seq_fun(seq=es2Old,ref=es2,subVec=sampVec,nsub=NSUB,tol=TOL)
ScoreNew <- pwmScoreDriver_fun(SEQ=es2New,DRIVER=TFsumm)
deltaNew <- sum(wtsPMW*(ScoreNew-es2Scores)^2)
if (deltaNew < deltaOld){
ScoreOld <- ScoreNew
deltaOld <- deltaNew
es2Old <- es2New
acc <- acc + 1
}
delta[iter] <- deltaOld
distance[iter] <- 1-(stringDist(c(paste0(es2),paste0(es2Old)), method = "hamming",
diag = FALSE, upper = FALSE)[1])/length(sampVec)
iter <- iter + 1
}
accept[i] <- acc/sub
}
delta
difference
distance
deltaNew
